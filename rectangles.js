// Generated by CoffeeScript 1.10.0
var Binary, Breeder, ImageMatcher, Rectangle, RectangleCollection, Scorer, go, imageMatcher, saveImage, start;

ImageMatcher = (function() {
  ImageMatcher.size = 256;

  function ImageMatcher(imageurl, numRectangles, numGenes, numBreed, numMut) {
    var body, breeder, canvas, g, i, img, j, rectangleCollection, ref, target;
    body = document.getElementById("canvases");
    this.bestScoreField = document.getElementById("bestScore");
    this.iterationField = document.getElementById("iteration");
    this.numBreed = numBreed;
    this.numMut = numMut;
    target = document.getElementById("target").getContext("2d");
    img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imageurl;
    img.onload = (function(_this) {
      return function() {
        target.drawImage(img, 0, 0);
        return _this.scorer = new Scorer(target);
      };
    })(this);
    this.canvases = [];
    this.scoredImages = [];
    this.rectangleCollections = [];
    for (i = j = 1, ref = numGenes; j <= ref; i = j += 1) {
      canvas = document.createElement("canvas");
      canvas.setAttribute("width", 255);
      canvas.setAttribute("height", 255);
      canvas.setAttribute("id", "canvas" + i);
      body.appendChild(canvas);
      this.canvases.push(canvas);
      g = canvas.getContext("2d");
      rectangleCollection = new RectangleCollection(Binary.random(numRectangles * Rectangle.bitCount), g);
      this.rectangleCollections.push(rectangleCollection);
      this.scoredImages.push([0, rectangleCollection]);
    }
    breeder = new Breeder;
    this.looseGraphics = [];
    this.iteration = 0;
  }

  ImageMatcher.prototype.run = function() {
    var i, j, k, ref, ref1;
    this.updateDisplays();
    this.recomputeScores();
    this.bestScoreField.innerHTML = this.findBestScore();
    this.iterationField.innerHTML = this.iteration;
    for (i = j = 0, ref = this.numBreed; j < ref; i = j += 1) {
      this.killWorst();
      this.killWorst();
      this.breed();
    }
    for (i = k = 0, ref1 = this.numMut; k < ref1; i = k += 1) {
      this.mutate();
    }
    return this.iteration++;
  };

  ImageMatcher.prototype.updateDisplays = function() {
    var j, len, ref, scoreImagePair;
    ref = this.scoredImages;
    for (j = 0, len = ref.length; j < len; j++) {
      scoreImagePair = ref[j];
      scoreImagePair[1].drawSelf();
    }
    return null;
  };

  ImageMatcher.prototype.recomputeScores = function() {
    var j, len, rectangleCollection, ref;
    this.scoredImages = [];
    ref = this.rectangleCollections;
    for (j = 0, len = ref.length; j < len; j++) {
      rectangleCollection = ref[j];
      this.scoredImages.push([this.scorer.score(rectangleCollection.getGraphics()), rectangleCollection]);
    }
    return null;
  };

  ImageMatcher.prototype.killWorst = function() {
    var i, j, len, pair, ref, worstIndex, worstScore;
    worstIndex = 0;
    worstScore = 0;
    ref = this.scoredImages;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      pair = ref[i];
      if (pair[0] > worstScore) {
        worstScore = pair[0];
        worstIndex = i;
      }
    }
    this.scoredImages.splice(worstIndex, 1);
    this.looseGraphics.push(this.rectangleCollections[worstIndex].getGraphics());
    return this.rectangleCollections.splice(worstIndex, 1);
  };

  ImageMatcher.prototype.breed = function() {
    var child1, child2, index1, index2, parent1, parent2;
    index1 = index2 = Math.floor(Math.random() * this.scoredImages.length);
    while (index2 === index1) {
      index2 = Math.floor(Math.random() * this.scoredImages.length);
    }
    parent1 = this.rectangleCollections[index1];
    parent2 = this.rectangleCollections[index2];
    child1 = new RectangleCollection(Breeder.breed(parent1.getBinary(), parent2.getBinary()), this.looseGraphics.pop());
    child2 = new RectangleCollection(Breeder.breed(parent2.getBinary(), parent1.getBinary()), this.looseGraphics.pop());
    this.rectangleCollections.push(child1);
    this.rectangleCollections.push(child2);
    this.scoredImages.push([0, child1]);
    return this.scoredImages.push([0, child2]);
  };

  ImageMatcher.prototype.mutate = function() {
    var index, mutated, mutatee;
    index = Math.floor(Math.random() * this.scoredImages.length);
    mutatee = this.rectangleCollections[index];
    mutated = new RectangleCollection(Breeder.mutate(mutatee.getBinary()), mutatee.getGraphics());
    this.rectangleCollections[index] = mutated;
    return this.scoredImages[index] = [0, mutated];
  };

  ImageMatcher.prototype.findBestScore = function() {
    var bestScore, j, len, pair, ref;
    bestScore = Number.MAX_VALUE;
    ref = this.scoredImages;
    for (j = 0, len = ref.length; j < len; j++) {
      pair = ref[j];
      if (pair[0] < bestScore) {
        bestScore = pair[0];
      }
    }
    return bestScore;
  };

  ImageMatcher.prototype.getBestRectangleCollectionIndex = function() {
    var bestIndex, bestScore, i, j, len, pair, ref;
    bestIndex = 0;
    bestScore = Number.MAX_VALUE;
    ref = this.scoredImages;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      pair = ref[i];
      if (pair[0] < bestScore) {
        bestScore = pair[0];
        bestIndex = i;
      }
    }
    return bestIndex;
  };

  return ImageMatcher;

})();

Rectangle = (function() {
  var varBitCount;

  varBitCount = 8;

  Rectangle.bitCount = 8 * varBitCount;

  function Rectangle(binary) {
    var a, start;
    start = 0;
    this.b = Binary.toInt(binary.slice(start, start + varBitCount));
    start += varBitCount;
    this.g = Binary.toInt(binary.slice(start, start + varBitCount));
    start += varBitCount;
    this.r = Binary.toInt(binary.slice(start, start + varBitCount));
    start += varBitCount;
    a = Binary.toInt(binary.slice(start, start + varBitCount));
    this.a = a / 255;
    start += varBitCount;
    this.x = Binary.toInt(binary.slice(start, start + varBitCount));
    start += varBitCount;
    this.y = Binary.toInt(binary.slice(start, start + varBitCount));
    start += varBitCount;
    this.xbar = Binary.toInt(binary.slice(start, start + varBitCount));
    start += varBitCount;
    this.ybar = Binary.toInt(binary.slice(start, start + varBitCount));
  }

  Rectangle.prototype.drawSelf = function(g) {
    var height, width;
    g.fillStyle = "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.a + ")";
    width = this.xbar - this.x;
    height = this.ybar - this.y;
    return g.fillRect(this.x, this.y, width, height);
  };

  Rectangle.prototype.printSelf = function() {
    console.log("x: " + this.x + ", y: " + this.y + ", xbar: " + this.xbar + ", ybar: " + this.ybar);
    return console.log("r: " + this.r + ", g: " + this.g + ", b: " + this.b + ", a: " + this.a + ", ");
  };

  return Rectangle;

})();

RectangleCollection = (function() {
  var size;

  size = 256;

  function RectangleCollection(binary1, g1) {
    var binary, start;
    this.binary = binary1;
    this.g = g1;
    binary = this.binary;
    this.rectangles = [];
    start = 0;
    while (start !== binary.length) {
      this.rectangles.push(new Rectangle(binary.slice(start, start + Rectangle.bitCount)));
      start += Rectangle.bitCount;
    }
  }

  RectangleCollection.prototype.getGraphics = function() {
    return this.g;
  };

  RectangleCollection.prototype.getBinary = function() {
    return this.binary;
  };

  RectangleCollection.prototype.drawSelf = function() {
    var j, len, rectangle, ref;
    this.g.clearRect(0, 0, size, size);
    ref = this.rectangles;
    for (j = 0, len = ref.length; j < len; j++) {
      rectangle = ref[j];
      rectangle.drawSelf(this.g);
    }
    return null;
  };

  RectangleCollection.prototype.printSelf = function() {
    var i, j, len, rectangle, ref, results;
    ref = this.rectangles;
    results = [];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      rectangle = ref[i];
      console.log("rectangle " + i);
      results.push(rectangle.printSelf());
    }
    return results;
  };

  return RectangleCollection;

})();

Scorer = (function() {
  function Scorer(base) {
    this.standardColors = (base.getImageData(0, 0, ImageMatcher.size, ImageMatcher.size)).data;
  }

  Scorer.prototype.score = function(graphics) {
    var i, imageColors, j, ref, score;
    imageColors = (graphics.getImageData(0, 0, ImageMatcher.size, ImageMatcher.size)).data;
    score = 0;
    for (i = j = 0, ref = imageColors.length; j < ref; i = j += 1) {
      if (i % 4 !== 3) {
        score += Math.abs(imageColors[i] - this.standardColors[i]);
      }
    }
    return score;
  };

  return Scorer;

})();

Breeder = (function() {
  function Breeder() {}

  Breeder.breed = function(parent1, parent2) {
    var splitPoint;
    splitPoint = Math.floor(Math.random() * parent.length);
    return parent1.slice(0, splitPoint).concat(parent2.slice(splitPoint));
  };

  Breeder.mutate = function(gene) {
    var bit, flipPoint;
    flipPoint = Math.floor(Math.random() * gene.length);
    bit = gene[flipPoint];
    gene[flipPoint] = bit === 1 ? 0 : 1;
    return gene;
  };

  return Breeder;

})();

Binary = (function() {
  function Binary() {}

  Binary.normalize = function(b1, b2) {
    var i;
    if (b1.length > b2.length) {
      b2 = ((function() {
        var j, ref, ref1, results;
        results = [];
        for (i = j = ref = b2.length, ref1 = b1.length; j < ref1; i = j += 1) {
          results.push(0);
        }
        return results;
      })()).concat(b2);
    } else if (b2.length > b1.length) {
      b1 = ((function() {
        var j, ref, ref1, results;
        results = [];
        for (i = j = ref = b1.length, ref1 = b2.length; j < ref1; i = j += 1) {
          results.push(0);
        }
        return results;
      })()).concat(b1);
    }
    return [b1, b2];
  };

  Binary.and = function(b1, b2) {
    var i, j, ref, ref1, results;
    ref = this.normalize(b1, b2), b1 = ref[0], b2 = ref[1];
    results = [];
    for (i = j = 0, ref1 = b1.length; j < ref1; i = j += 1) {
      results.push(b1[i] && b2[i]);
    }
    return results;
  };

  Binary.or = function(b1, b2) {
    var i, j, ref, ref1, results;
    ref = this.normalize(b1, b2), b1 = ref[0], b2 = ref[1];
    results = [];
    for (i = j = 0, ref1 = b1.length; j < ref1; i = j += 1) {
      results.push(b1[i] || b2[i]);
    }
    return results;
  };

  Binary.toInt = function(b) {
    return parseInt(b.join(""), 2);
  };

  Binary.random = function(numbits) {
    var i, j, ref, results;
    results = [];
    for (i = j = 1, ref = numbits; j <= ref; i = j += 1) {
      results.push(Math.random() < .5 ? 1 : 0);
    }
    return results;
  };

  return Binary;

})();

imageMatcher = null;

go = function() {
  var imageURL, numBreed, numGenes, numMut, numRectangles;
  numRectangles = document.getElementById("numrectangles").value;
  numGenes = document.getElementById("numgenes").value;
  imageURL = document.getElementById("imageurl").value;
  numBreed = document.getElementById("numbreed").value;
  numMut = document.getElementById("nummut").value;
  imageMatcher = new ImageMatcher(imageURL, numRectangles, numGenes, numBreed, numMut);
  document.getElementById("instantiation").hidden = "true";
  return setTimeout((function() {
    return start();
  }), 1000);
};

start = function() {
  return setInterval((function() {
    return imageMatcher.run();
  }), 0);
};

saveImage = function() {
  var dataURL, index;
  index = imageMatcher.getBestRectangleCollectionIndex() + 1;
  dataURL = document.getElementById("canvas" + index).toDataURL();
  return document.getElementById("snapshot").src = dataURL;
};

document.getElementById("save").onclick = saveImage;

document.getElementById("go").onclick = go;
